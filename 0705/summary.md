UDP(user datagram protocol)

TCP와 달리 흐름제어를 하지 않는다.   
신뢰성이 낮지만 데이터 전송 속도가 빠르다.   
연결 설정 과정이 필요 없다(listen, accept 함수 불필요).   
하나의 소켓으로 둘 이상의 호스트와 통신이 가능하다.   
입력함수의 호출횟수와 출력함수의 호출횟수가 완벽히 일치해야 송신된 데이터 전부를 수신할 수 있다.

하나의 호스트와 오래동안 데이터를 송수신해야한다면 udp 소켓을 connected 소켓으로 만드는 것이 효율적이다.

recvfrom을 먼저 호출하는 서버에서 대부분 bind를 호출한다.   
데이터를 받기 위해서 운영체제에게 소켓의 ip주소와 포트번호를 알려줘야 하기 때문이다.

하지만 sendto를 먼저 호출하는 클라이언트는 bind를 호출하지 않는다.   
sendto함수 과정에서 운영체제가 자동으로 ip주소와 포트번호를 소켓에 할당하기 때문이다.

리눅스의 close, 윈도우의 closesocket 함수호출은 완전종료를 의미한다.   
즉 입력, 출력 스트림 모두 닫는 것이다.

하지만 모든 데이터 전송을 끝내고 그에 대한 답장을 받아야 할 때 완전종료를 하면 받을 수 없다.   
출력 스트림만 닫고, 입력 스트림은 살려두면 답장을 받을 수 있다.

출력 스트림을 종료하면 상대 호스트로 EOF가 전송된다.   
클라이언트는 EOF의 수신을 함수의 반환 값을 통해서 확인이 가능하다.

DNS 서버   
도메인 이름을 ip주소로 변환하기 위해서 웹브라우저가 DNS 서버에게 ip주소를 물어본다.

소켓의 타입은 소켓 생성시 한번 결정되면 변경이 불가능하다.

Time-wait 상태   
연결 종료 단계인 four way handshaking에서 마지막 ack 메시지가 전송되지 않은 경우   
상대 호스트는 자신이 보낸 메시지를 받지 못했다고 판단하여 동일 메시지를 재 전송할 것이다.   
그런데 완전 종료된 상태라면 메시지를 받지 못하기 때문에 상대 호스트는 마지막 ack 메시지를 받지 못한다.   
이러한 경우를 위해 four way handshaking 이후에 소켓이 바로 소멸되지 않고 time-wait 상태를 일정시간 거친다.

nagle 알고리즘    
앞서 전송한 데이터에 대한 ack 메시지를 받아야만, 다음 데이터를 전송하는 알고리즘이다.   
ack 메시지를 받을 때 까지 전송할 데이터를 버퍼에 두었다가 한번에 보내기 때문에 네트워크 트래픽이 적다.   
nagle 알고리즘을 적용하지 않는다면 전송속도는 향상될 수 있으나 네트워크 트래픽이 증가한다.