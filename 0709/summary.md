select 기반 IO 멀티플렉싱이 느린 이유   
1. select 함수 호출 이후에 모든 파일 디스크립터를 대상으로 하는 반복문   
2. select 함수를 호출할 때마다 관찰 대상에 대한 정보를 운영체제에게 전달

select 함수의 해결책   
운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고서, 관찰 대상의 범위 또는 내용에 변경이 있을 때 변경사항만 알려주자   
-> 리눅스의 epoll, 윈도우의 IOCP

epoll의 장점   
1. 상태변화의 확인을 위한 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다(운영체제가 변경사항이 있는 파일 디스크립터만 알려주기 때문).   
2. select 함수에 대응하는 epoll_wait 함수 호출 시, 관찰 대상의 정보를 매번 전달할 필요가 없다.

레벨 트리거: 입력버퍼에 데이터가 남아있는 동안에 계속해서 이벤트가 등록된다.   
엣지 트리거: 입력버퍼로 데이터가 수신된 상황에서 딱 한번만 이벤트가 등록된다. 때문에 데이터가 남아있다고 해서 이벤트를 추가로 등록하지 않는다.   
(엣지 트리거는 입력 버퍼에 수신된 데이터보다 입력받을 배열 크기가 작은 경우 일부만 받아서 echo하고 이후에는 이벤트가 등록되지 않기 때문에 나머지 데이터는 읽지 않는 문제가 발생할 수 있다.)

read 함수는 입력버퍼가 비어서 더 이상 읽어 들일 데이터가 없을 때 -1을 반환하고, 이 때 errno에는 상수 EAGAIN이 저장된다.   
엣지트리거는 입력버퍼에 데이터가 수신될 때만 이벤트가 등록되는 특성 때문에 소켓을 non-blocking으로 변환하지 않으면 read, write 함수에서 오랫동안 대기할 수 있다.

엣지 트리거의 장점: 데이터의 수신과 데이터가 처리되는 시점을 분리할 수 있다.   
(입력버퍼에 데이터가 있어도 이벤트가 등록되지 않으며, 내가 원하는 시간에 데이터를 처리할 수 있기 때문에 서버가 굉장히 유연해진다)