IO 컴플리션 포트   
IOCP를 구현한 이론적 배경: 동시에 수행할 수 있는 스레드 개수의 상한을 설정할 수 있어야 한다.   
IOCP에서는 완료된 IO의 정보가 completion port 커널 오브젝트에 등록된다.   
IO 컴플리션 포트를 생성하면 윈도우 커널은 5개의 서로 다른 데이터 구조를 생성한다.

Device List   
새로운 장치(소켓 등)를 IO 컴플리션 포트와 연계시킬 때마다 시스템은 IO 컴플리션 포트의 내부 데이터 구조인 장치 리스트에 새로운 항목을 추가한다.

IO Completion Queue(FIFO)   
장치에 대한 비동기 IO요청이 완료되면 시스템은 장치와 연계된 IO 컴플리션 포트가 있는지 확인한다.   
연계된 IO 컴플리션 포트가 있다면 IO 컴플리션 큐에 IO 요청의 완료통지를 나타내는 항목을 삽입한다.   
각 항목에는 송수신된 바이트 수, 장치와 IO 컴플리션 포트를 연계할 때 지정한 컴플리션 키 값, 비동기 IO 작업을 요청할 때 사용하였던 OVERLAPPED 구조체를 가리키는 포인터, 에러코드를 포함한다.   
비동기 장치 IO 작업이 완료되어 IO 컴플리션 포트를 통해 완료 통지가 전달될 때 이를 곧바로 처리할 수 있도록 스레드를 대기 상태로 유지해야 하는데, 이를 위해 GetQueuedCompletionStatus 함수를 사용하면 된다.

Waiting Thread Queue(LIFO)   
스레드풀 내의 여러 개의 스레드들이 각기 GetQueuedCompletionStatus 함수를 호출하면 이 함수를 호출한 스레드의 ID 값이 대기 스레드 큐에 삽입된다.   
IO 컴플리션 큐에 항목이 추가되면 IO 컴플리션 포트는 대기 스레드 큐에 있는 스레드 중 하나를 깨우게 되고, 이 스레드는 컴플리션 큐에 삽입된 항목으로 부터 송수신된 바이트 수, 컴플리션 키, OVERLAPPED 구조체의 주소를 가져오게 된다.   
이러한 정보는 GetQueuedCompletionStatus 함수의 lpNumberOfBytesTransferred, lpCompletionKey, *lpOverlapped 매개변수를 통해 전달된다.   
후입선출 알고리즘을 이용하면 스케줄되지 않는 스레드들이 사용하는 메모리를 디스크로 내보낼 수 있다.

Released Thread List   
IO 컴플리션 포트가 특정 스레드의 수행을 재개시키는 경우 released thread list에 깨어난 스레드의 ID를 기록해 둔다.   
이렇게 함으로써 IO 컴플리션 포트는 어떤 스레드가 깨어났는지를 알 수 있으며, 이 스레드의 수행 상황을 지속적으로 확인할 수 있게 된다.

Paused Thread List   
released thread list에 삽입된 스레드 중 하나가 어떤 함수를 호출하였더니 정지 상태로 진입하면 release thread list로부터 이 스레드의 ID 값을 빼내어 paused thread list로 항목을 옮긴다.

스레드 풀에 존재하는 스레드의 개수를 동시에 수행 가능한 스레드의 개수보다 큰 값으로 유지하는 것이 좋은 이유   
스레드 수를 CPU 코어수와 동일하게 가져가는 경우 특정 스레드가 작업 중에 정지 상태에 진입하면 사용 가능한 스레드가 없기 때문에 해당 코어는 사용하지 못하게 된다.   
그래서 스레드 수를 CPU 코어수보다 더 많이 생성해서 스레드가 정지 상태에 진입해도 다른 스레드가 해당 코어를 사용하게 함으로 CPU를 최대한 사용하게 만들 수 있다.